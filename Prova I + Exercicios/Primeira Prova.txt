Primeira Prova – Linguagem de Programação II – UFPB – 2020.2
Professor: Carlos Eduardo Batista

***** ATENÇÃO!!!!!! LEIA TODAS AS INSTRUÇÕES!!!!!! ***********

- A prova tem 6 questões que somam 14 pontos – porém a nota máxima é 10,00

- As respostas da prova devem ser enviadas por e-mail (para bidu @ ci.ufpb.br)
 em um ÚNICO arquivo ZIP contendo os códigos solicitados e os arquivos de texto.

- O título do e-mail e do arquivo ZIP deverá conter "[PROVA01-LPII-211]", 
 seu nome e matrícula.

- TODO CÓDIGO *DEVE* ser comentado com a explicação da lógica e demais 
 informações solicitadas na questão.

- Plágio será punido com a perda da pontuação das respostas por todos os
 participantes.

- O envio deverá ser feito até as 16h do dia 29/09/2021

***** ATENÇÃO!!!!!! LEIA TODAS AS INSTRUÇÕES!!!!!! ***********

(Questão 1 - 4 pontos) Faça um programa em C/C++ que receberá 3 parâmetros: 
se usará processos ou threads, quantas instâncias serão criadas e um valor em 
metros, que será o tamanho de uma pista fictícia para uma corrida de 'lebres'.

Exemplo de execução:

	$ ./corrida -t 5 1000 (5 threads, pista de 1000m)
	lebre 0 saltou 30cm (total: 30)
	lebre 2 saltou 42cm (total: 42)
	...
	lebre 2 saltou 31cm (total: 1002)
	lebre 2 venceu! 

	$ ./corrida -p 10 500 (10 processos, pista de 500m)
	lebre 1 saltou 20cm (total: 20)
	lebre 0 saltou 43cm (total: 43)
	...
	lebre 3 saltou 44cm (total: 520)
	lebre 3 venceu!

Os processos / threads vão representar lebres em uma corrida fictícia; eles 
devem executar uma função que receberá dois parâmetros: um valor inteiro que
identifique a lebre (índice) e um valor real (float ou double) que represente
a distância máxima do salto dessa lebre. A função possui um loop onde cada 
salto acontece a partir da geração de um valor aleatório entre 1 e o valor 
máximo definido para a "lebre", considerando valores expressos em cm. 

Faça as lebres "correrem" nessa "pista" com o tamanho definido na execução do
programa. Para cada vez que a função de cada processo/thread (lebre) executar
a geração de valores aleatórios (entre 1 e a distância máxima do salto da lebre),
uma soma de todos os saltos deverá ser armazenada em uma variável com o quanto a
lebre já percorreu na pista (uma variável float ou double no escopo da função 
que a lebre executa). A função permanece em loop, "saltando", até que o valor
acumulado seja igual ou superior ao tamanho da pista.

A cada "salto" (iteração realizada pela função associada ao processo ou a 
thread), deverá ser exibida uma mensagem contendo a distância do salto 
efetuado e qual distância total percorrida (dormindo 1s - função sleep - até 
que dê outro salto). A primeira 'lebre' (thread ou processo) que finalizar sua
função (ou seja, tenha a variável que represente o quanto a lebre já percorreu
com valor maior ou igual ao tamanho da pista) deverá exibir uma mensagem onde 
se declara vencedora e o programa deverá ser finalizado. 

-----------------------------------------------------

(Questão 2 - 1 ponto) Utilize a implementação da questão 1 para destacar as 
diferenças do uso de threads e processos na programação em C/C++. Destaque 
trechos do código e realce as diferenças também as diferenças do ponto de vista
 da execução. A resposta deverá ser colocada em um arquivo de texto (extensão 
“.txt”) separado.

-----------------------------------------------------

(Questão 3 - 3 pontos) Faça um programa em C/C++ que crie um arquivo de texto 
que funcionará como um dicionário contendo todas as strings com 4 caracteres 
alfabéticos maiúsculos (de "AAAA" a "ZZZZ"). Cada letra do alfabeto (de A a Z)
deverá ter sua parte do dicionário gerada por uma thread individual, de tal 
forma que esta thread gere todas as strings iniciadas por aquela letra (ex. a 
thread que gerará as strings começando com a letra 'C' gerará as strings de 
"CAAA" a "CZZZ"). A thread principal deverá aguardar a geração de todas as 
partes e gerar um arquivo de texto contendo o dicionário inteiro. 

Referências para manipulação de arquivos em C:

https://www.inf.pucrs.br/~pinho/LaproI/Arquivos/Arquivos.htm (português)
http://www.csc.villanova.edu/~mdamian/C/c-files.htm (inglês)

-----------------------------------------------------

(Questão 4 - 1 ponto) Utilize a execução e a implementação da questão anterior 
para discutir o ciclo de vida das threads. Faça a relação de cada invocação a 
funções da API PThreads com a máquina de estados (descrevendo seus estados e 
transições) que representa o ciclo de vida das threads. A resposta deverá ser
 colocada em um arquivo de texto (extensão “.txt”) separado.

-----------------------------------------------------

(Questão 5 - 4 pontos) Faça um programa em C/C++ que declare uma variável 
global do tipo double; faça o programa criar um processo que defina um valor 
aleatório entre 20 e 80 para esta variável (o processo deve retornar o valor 
aleatório gerado para o a thread principal/main). 

Em seguida, o programa deverá criar 12 threads, que receberão um valor inteiro
que representa um índice único (de 0 a 11). Faça cada uma das threads realizar 
uma função que verifique se seu identificador é divisível por 3 (três). Caso o
identificador seja divisível, a função deve realizar um laço de repetição que 
faça 100 incrementos (+1) na variável global; caso o identificador não seja 
divisível, a função deve realizar um laço que faça 33 decrementos (-1) na 
variável global.

A cada iteração essa função deve exibir o identificador da thread e o novo 
valor da variável global, e as threads cujo identificador for divisível por 
3 devem dormir um tempo aleatório entre 1s e 3s (as demais dormem sempre 1s).
Após o término de todas as threads, exiba o valor final da variável global
na thread principal. 

Comente o código explicando o conceito de concorrência (e suas diferentes 
formas de realização nos SO mais facilmente encontrados). Explique quais 
são os elementos do Sistema Operacional e da arquitetura do computador 
envolvidos na execução do programa e como se comportam para que a lógica 
implementada seja executada de forma concorrente. 

-----------------------------------------------------

(Questão 6 - 1 ponto)  Crie um arquivo de texto explicando o que você entende 
por consistência de memória; faça um esqueleto de código explicando se algo 
deveria ser modificado no código da questão anterior com relação a manutenção 
da consistência de memória.
